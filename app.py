{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "32674d5a-9c0b-4bf9-998c-9d2b0b81426b",
   "metadata": {},
   "outputs": [],
   "source": [
    "import io\n",
    "import zipfile\n",
    "import requests\n",
    "from PIL import Image\n",
    "import pandas as pd\n",
    "import streamlit as st\n",
    "\n",
    "# ===========================\n",
    "# Amazon Image Downloader Web\n",
    "# ===========================\n",
    "\n",
    "st.title(\"Amazon Image Downloader (Excel → ZIP)\")\n",
    "st.write(\n",
    "    \"Upload an Excel file with columns **sku** and **url**. \"\n",
    "    \"The app will download the images and give you a ZIP file.\"\n",
    ")\n",
    "\n",
    "# ---------- HELPER FUNCTION ----------\n",
    "\n",
    "def download_images_from_excel(uploaded_file):\n",
    "    \"\"\"\n",
    "    Takes an uploaded Excel file, reads sku + url,\n",
    "    downloads images, and returns a ZIP (as BytesIO).\n",
    "    \"\"\"\n",
    "    # Read Excel into DataFrame\n",
    "    df = pd.read_excel(uploaded_file)\n",
    "\n",
    "    # Normalize column names\n",
    "    df.columns = [c.strip().lower() for c in df.columns]\n",
    "\n",
    "    if \"sku\" not in df.columns or \"url\" not in df.columns:\n",
    "        raise ValueError(\"Excel must contain 'sku' and 'url' columns.\")\n",
    "\n",
    "    # Create an in-memory ZIP file\n",
    "    zip_buffer = io.BytesIO()\n",
    "\n",
    "    with zipfile.ZipFile(zip_buffer, \"w\", zipfile.ZIP_DEFLATED) as zipf:\n",
    "        for idx, row in df.iterrows():\n",
    "            sku = str(row[\"sku\"]).strip()\n",
    "            url = str(row[\"url\"]).strip()\n",
    "\n",
    "            if not sku or not url or url.lower() == \"nan\":\n",
    "                continue\n",
    "\n",
    "            try:\n",
    "                # -------- DIRECT IMAGE DOWNLOAD --------\n",
    "                # This assumes `url` is a direct image link (jpg/png/webp).\n",
    "                resp = requests.get(url, timeout=25)\n",
    "                resp.raise_for_status()\n",
    "\n",
    "                # Guess extension from URL\n",
    "                ext = \".jpg\"\n",
    "                for candidate in [\".jpg\", \".jpeg\", \".png\", \".webp\"]:\n",
    "                    if candidate in url.lower():\n",
    "                        ext = candidate\n",
    "                        break\n",
    "\n",
    "                # Open with PIL\n",
    "                img = Image.open(io.BytesIO(resp.content)).convert(\"RGB\")\n",
    "\n",
    "                # OPTIONAL: resize into 1500x1500 white canvas\n",
    "                target = 1500\n",
    "                w, h = img.size\n",
    "\n",
    "                if w > target or h > target:\n",
    "                    scale = min(target / w, target / h)\n",
    "                    new_w = max(1, int(w * scale))\n",
    "                    new_h = max(1, int(h * scale))\n",
    "                    img = img.resize((new_w, new_h), Image.LANCZOS)\n",
    "                    w, h = img.size\n",
    "\n",
    "                canvas = Image.new(\"RGB\", (target, target), (255, 255, 255))\n",
    "                offset_x = (target - w) // 2\n",
    "                offset_y = (target - h) // 2\n",
    "                canvas.paste(img, (offset_x, offset_y))\n",
    "\n",
    "                # Save image to memory\n",
    "                img_bytes = io.BytesIO()\n",
    "                canvas.save(img_bytes, format=\"JPEG\", quality=95)\n",
    "                img_bytes.seek(0)\n",
    "\n",
    "                # Name: sku-1, sku-2, ... (if multiple rows with same SKU)\n",
    "                base_name = sku\n",
    "                counter = 1\n",
    "                filename = f\"{base_name}-{counter}.jpg\"\n",
    "                while filename in zipf.namelist():\n",
    "                    counter += 1\n",
    "                    filename = f\"{base_name}-{counter}.jpg\"\n",
    "\n",
    "                zipf.writestr(filename, img_bytes.getvalue())\n",
    "\n",
    "            except Exception as e:\n",
    "                # Show error but continue with next row\n",
    "                st.write(f\"Error downloading for SKU {sku}: {e}\")\n",
    "                continue\n",
    "\n",
    "    zip_buffer.seek(0)\n",
    "    return zip_buffer\n",
    "\n",
    "# ---------- STREAMLIT UI ----------\n",
    "\n",
    "uploaded_file = st.file_uploader(\n",
    "    \"Upload Excel file (.xlsx)\",\n",
    "    type=[\"xlsx\"],\n",
    "    help=\"File must have 'sku' and 'url' columns.\",\n",
    ")\n",
    "\n",
    "if uploaded_file is not None:\n",
    "    st.write(\"✅ File uploaded.\")\n",
    "    if st.button(\"Start Download\"):\n",
    "        with st.spinner(\"Downloading images and building ZIP...\"):\n",
    "            try:\n",
    "                zip_buffer = download_images_from_excel(uploaded_file)\n",
    "                st.success(\"Done! Click below to download your images.\")\n",
    "\n",
    "                st.download_button(\n",
    "                    label=\"Download Images ZIP\",\n",
    "                    data=zip_buffer.getvalue(),\n",
    "                    file_name=\"images.zip\",\n",
    "                    mime=\"application/zip\",\n",
    "                )\n",
    "            except Exception as e:\n",
    "                st.error(f\"Something went wrong: {e}\")\n",
    "else:\n",
    "    st.info(\"Please upload an Excel file to continue.\")\n"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.11.7"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
